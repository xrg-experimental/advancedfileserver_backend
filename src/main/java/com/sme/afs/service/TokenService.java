package com.sme.afs.service;

import com.sme.afs.config.BlobUrlProperties;
import com.sme.afs.model.BlobUrl;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.security.SecureRandom;
import java.util.Base64;

/**
 * Service for generating and validating cryptographically secure tokens for blob URLs.
 * Uses SecureRandom for token generation and URL-safe Base64 encoding.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class TokenService {

    private final BlobUrlProperties blobUrlProperties;
    private final SecureRandom secureRandom = new SecureRandom();

    /**
     * Generates a cryptographically secure random token for blob URLs.
     * Uses SecureRandom with URL-safe Base64 encoding to ensure tokens are
     * unpredictable and safe for use in URLs.
     *
     * @return A secure, URL-safe token string
     */
    public String generateSecureToken() {
        byte[] tokenBytes = new byte[blobUrlProperties.getTokenLength()];
        secureRandom.nextBytes(tokenBytes);
        
        // Use URL-safe Base64 encoding (no padding) for clean URLs
        String token = Base64.getUrlEncoder().withoutPadding().encodeToString(tokenBytes);
        
        log.debug("Generated secure token of length: {}", token.length());
        return token;
    }

    /**
     * Validates the format and structure of a token.
     * Checks that the token is properly formatted and has the expected characteristics
     * of a token generated by this service.
     *
     * @param token The token to validate
     * @return true if the token format is valid, false otherwise
     */
    public boolean validateTokenFormat(String token) {
        if (token == null || token.trim().isEmpty()) {
            log.debug("Token validation failed: null or empty token");
            return false;
        }

        // Check length - Base64 encoding of tokenLength bytes should produce a predictable length
        // Base64 encoding produces 4 characters for every 3 bytes, but we use no padding
        int expectedMinLength = (blobUrlProperties.getTokenLength() * 4) / 3;
        int expectedMaxLength = expectedMinLength + 2; // Account for rounding in no-padding encoding
        
        if (token.length() < expectedMinLength || token.length() > expectedMaxLength) {
            log.debug("Token validation failed: invalid length {} (expected {}-{})", 
                     token.length(), expectedMinLength, expectedMaxLength);
            return false;
        }

        // Check that token contains only URL-safe Base64 characters
        if (!token.matches("^[A-Za-z0-9_-]+$")) {
            log.debug("Token validation failed: contains invalid characters");
            return false;
        }

        return true;
    }

    /**
     * Checks if a blob URL has expired based on its expiration timestamp.
     *
     * @param blobUrl The blob URL entity to check
     * @return true if the blob URL has expired, false otherwise
     */
    public boolean isTokenExpired(BlobUrl blobUrl) {
        if (blobUrl == null) {
            return true;
        }
        
        boolean expired = blobUrl.isExpired();
        log.debug("Token {} expiration check: {}", blobUrl.getToken(), expired ? "EXPIRED" : "ACTIVE");
        return expired;
    }

    /**
     * Validates that a token exists and is not expired.
     * This is a convenience method that combines format validation with expiration checking.
     *
     * @param token The token string to validate
     * @param blobUrl The blob URL entity associated with the token (can be null)
     * @return true if the token is valid and not expired, false otherwise
     */
    public boolean validateToken(String token, BlobUrl blobUrl) {
        if (!validateTokenFormat(token)) {
            return false;
        }
        
        if (blobUrl == null) {
            log.debug("Token validation failed: no associated blob URL found");
            return false;
        }
        
        if (isTokenExpired(blobUrl)) {
            log.debug("Token validation failed: blob URL has expired");
            return false;
        }
        
        return true;
    }
}